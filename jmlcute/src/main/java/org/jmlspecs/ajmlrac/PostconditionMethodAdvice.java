/*
 * Copyright (C) 2008-2009 Federal University of Pernambuco and 
 * University of Central Florida
 *
 * This file is part of AJML
 *
 * AJML is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * AJML is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with AJML; see the file COPYING.  If not, write to
 * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Id: PostconditionMethodAdvice.java,v 1.0 2009/01/18 10:51:36 henriquerebelo Exp $
 * 
 * This file is based on the original $Id: PostconditionMethod.java,v 1.18 2006/02/11 03:06:44 chalin Exp $
 * by Yoonsik Cheon
 */

package org.jmlspecs.ajmlrac;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.jmlspecs.checker.JmlMethodDeclaration;
import org.jmlspecs.checker.JmlTypeDeclaration;
import org.jmlspecs.util.AspectUtil;
import org.multijava.mjc.CClassType;
import org.multijava.mjc.CType;
import org.multijava.mjc.JMethodDeclarationType;

import com.thoughtworks.qdox.model.JavaMethod;

/**
 * A class for generating a postcondition check method as an AspecJ advice.
 * The postcondition checking code is automatic wrapped with code that checks
 * inherited postconditions if any, and throws an appropriate exception to signal
 * a violation if the postcondition is violated at runtime.
 * <p/>
 * <p>
 * The class implements a variant of the <em>Template Pattern</em>
 * [GoF95], prescribed in the class {@link AssertionMethod}.
 * </p>
 *
 * @author Henrique Rebelo
 * @version $Revision: 1.0 $
 * @see AssertionMethod
 */

public class PostconditionMethodAdvice extends PreOrPostconditionMethod {

    // ----------------------------------------------------------------------
    // CONSTRUCTORS
    // ----------------------------------------------------------------------

    /**
     * Construct a new <tt>PostconditionMethodAdvice</tt> object.
     *
     * @param mdecl method for which the postcondition method is generated
     */
    public PostconditionMethodAdvice(JmlTypeDeclaration typeDecl,
                                     JmlMethodDeclaration mdecl,
                                     String restoreMethod) {
        super(typeDecl, mdecl, restoreMethod);
        this.prefix = MN_CHECK_POST;
        this.methodName = prefix + methodName(mdecl) + "$" + typeDecl.ident();
        this.exceptionToThrow = "JMLExitNormalPostconditionError";
        this.returnType = mdecl.returnType();

        // javadoc to be added to the generated method
        boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
        if (isMethodCrosscutSpecChecking) {
            this.javadoc = "/** Generated by AspectJML to check the normal " +
                    "postcondition of\n" +
                    " * members intercepted by " + mdecl.ident() + " pointcut. */";
        } else {
            this.javadoc = "/** Generated by AspectJML to check the normal " +
                    "postcondition of\n" +
                    " * method " + mdecl.ident() + ". */";
        }
    }

    // ----------------------------------------------------------------------
    // TRANSLATION
    // ----------------------------------------------------------------------
    public JMethodDeclarationType generate(RacNode stmt) {
        throw new UnsupportedOperationException();
    }


    /**
     * Generate and return a postcondition checking method. Append to the
     * body (<tt>stmt</tt>) (1) code to check the inherited postcondition
     * if any, and (2) code to throw an appropriate exception to notify a
     * violation if the postcondition is violated at runtime.
     *
     * @param stmt code to evaluate the postcondition; the result is supposed
     *             to be stored in the variable <code>VN_ASSERTION</code>.
     *             A <code>null</code> value means that no postcondition is
     *             specified or it is not executable.
     */
    public JMethodDeclarationType generate(RacNode stmt, String nPostPred,
                                           List xPostCode, HashMap oldExprs, HashMap oldExprsDecl,
                                           List preExprs, List preExprsDecl, HashMap oldVarsDecl,
                                           String instrumentationType, long visibility) {
        this.hasOldVariables = AspectUtil.getInstance().hasElementsStoredOldExpressions(oldVarsDecl);
        this.hasOldExpressions = AspectUtil.getInstance().hasElementsStoredOldExpressions(oldExprs);
        this.hasPreExpressions = preExprs.size() > 0;
        StringBuffer code = new StringBuffer();
        if (instrumentationType.equals("clientAwareChecking")) {
            if (visibility == ACC_PUBLIC) {
                this.exceptionToThrow = "JMLExitPublicNormalPostconditionError";
            } else if (visibility == ACC_PROTECTED) {
                this.exceptionToThrow = "JMLExitProtectedNormalPostconditionError";
            } else if (visibility == 0L) { //default
                this.exceptionToThrow = "JMLExitDefaultNormalPostconditionError";
            } else if (visibility == ACC_PRIVATE) {
                this.exceptionToThrow = "JMLExitPrivateNormalPostconditionError";
            }
        }
        if ((methodDecl.hasSpecification())) {
            if (hasPreExpressions || hasOldVariables || hasOldExpressions) {
                if ((nPostPred.equals(""))) {
                    nPostPred = "true";
                }
                code = this.generateNormalAndXPostconditionWithAroundAdvice(nPostPred, xPostCode, oldExprs, oldExprsDecl, preExprs, preExprsDecl, oldVarsDecl, instrumentationType, visibility);
                AspectUtil.getInstance().setAroundAdvice(true);
            } else {
                code = this.generateNormalAndXPostCheckWithAfterReturningAndAfterThrowingAdvice(nPostPred, xPostCode, instrumentationType, visibility);
            }
        } else {
            if (!nPostPred.equals("") && !nPostPred.equals("true")) {
                code = this.generateNormalPostCheckWithAfterReturningAdvice(nPostPred, instrumentationType, visibility);
            }
            this.setJavadocForXPostMethodAdvice();
            code.append(this.generateXPostcheckWithAfterThrowingAdvice(xPostCode, instrumentationType, visibility)).append("\n");
        }
        return RacParser.parseMethod(code.toString(), stmt);
    }

    private void setJavadocForXPostMethodAdvice() {
        boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
        if (isMethodCrosscutSpecChecking) {
            this.javadoc = "/**\n"
                    + " * Generated by AspectJML to check the exceptional postcondition of\n"
                    + " * members intercepted by " + this.methodDecl.ident() + " pointcut.\n"
                    + " */\n";
        } else {
            this.javadoc = "/**\n"
                    + " * Generated by AspectJML to check the exceptional postcondition of\n"
                    + " * method " + this.methodDecl.ident() + ".\n"
                    + " */\n";
        }
    }

    private void setJavadocForNPostAndXPostMethodAdvice() {
        boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
        if (isMethodCrosscutSpecChecking) {
            javadoc = "/** Generated by AspectJML to check the normal " +
                    "and\n" +
                    " * exceptional postcondition of members intercepted by " + this.methodDecl.ident() + " pointcut. */";
        } else {
            javadoc = "/** Generated by AspectJML to check the normal " +
                    "and\n" +
                    " * exceptional postcondition of method " + this.methodDecl.ident() + ". */";
        }

    }

    private StringBuffer generateNormalAndXPostconditionWithAroundAdvice(
            String nPostPred, List xPostCode,
            HashMap oldExprs, HashMap oldExprsDecl,
            List preExprs, List preExprsDecl, HashMap oldVarsDecl,
            String instrumentationType, long visibility) {
        StringBuffer code;
        boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
        this.setJavadocForNPostAndXPostMethodAdvice();
        code = this.buildAdviceHeader("NPAndXPAssertionMethodsWithAroundAdvice", instrumentationType, visibility,
                isMethodCrosscutSpecChecking);
        code.append(" {\n");
        JavaMethod jm = AspectUtil.getInstance().getCorrespondingJavaMethodThroughJMLMethod(this.methodDecl.getMethod().owner().getJavaName(), this.methodDecl);

        boolean isFlexibleXCS = false;
        if (jm != null) {
            isFlexibleXCS = AspectUtil.getInstance().isXCSFlexible(jm);
        }

        String methodReturnType;
        if ((jm != null) && !this.methodDecl.isConstructor()) {
            if (jm.getReturnType().toString().equals(this.methodDecl.returnType().toString())) {
                methodReturnType = this.methodDecl.returnType().toString();
            } else {
                methodReturnType = jm.getReturnType().toString();
            }
        } else {
            methodReturnType = this.methodDecl.returnType().toString();
        }

        if (isMethodCrosscutSpecChecking) {
            code.append("     String runtimeObjectOrStaticType = \"\";\n");
            code.append("     String methSig = \"\";\n");
            code.append("     if(thisJoinPoint.getKind().equals(thisJoinPoint.CONSTRUCTOR_CALL)){\n");
            code.append("       runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
            code.append("       methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(runtimeObjectOrStaticType));\n");
            code.append("       methSig = methSig.replace(runtimeObjectOrStaticType, runtimeObjectOrStaticType+\".<init>\");\n");
            code.append("     }\n");
            code.append("     else{\n");
            code.append("       if(java.lang.reflect.Modifier.isStatic(thisJoinPoint.getSignature().getModifiers())){\n");
            code.append("          runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
            code.append("       }\n");
            code.append("       else{\n");
            code.append("          if(thisJoinPoint.getThis() != null){\n");
            code.append("            runtimeObjectOrStaticType = thisJoinPoint.getThis().getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(thisJoinPoint.getThis()));\n");
            code.append("          }\n");
            code.append("          else {\n");
            code.append("            runtimeObjectOrStaticType = thisJoinPoint.getTarget().getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(thisJoinPoint.getTarget()));\n");
            code.append("          }\n");
            code.append("       }\n");
            code.append("         methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(thisJoinPoint.getSignature().getName()));\n");
            code.append("    }\n");
        }
        String qcode;
        if (isMethodCrosscutSpecChecking) {
            qcode = this.getQuantifierInnerClasses(nPostPred.replace("object$rac", "rac$result"));
            code.append("    java.lang.Object rac$result");
            code.append(" = null;\n");
            if (qcode.contains("rac$result")) {
                code.append("    final ").append(methodReturnType).append(" rac$result$qcode;\n");
                qcode = qcode.replace("rac$result", "rac$result$qcode");
            }
        } else {
            qcode = this.getQuantifierInnerClasses(nPostPred.replace("object$rac", "rac$result"));
            if (!(methodReturnType.equals("void"))) {
                code.append("    ").append(AspectUtil.processMethSig(methodReturnType)).append(" ").append("rac$result");
                code.append(" = ").append(TransUtils.defaultValue(methodDecl.returnType())).append(";\n");
                if (qcode.contains("rac$result")) {
                    code.append("    final ").append(AspectUtil.processMethSig(methodReturnType)).append(" ").append("rac$result$qcode;\n");
                    qcode = qcode.replace("rac$result", "rac$result$qcode");
                }
            }
            if (methodDecl.isConstructor() && (instrumentationType.equals("callSite") || instrumentationType.equals("clientAwareChecking"))) {
                String classQualifiedName = this.typeDecl.getCClass().getJavaName();
                code.append("    ").append(classQualifiedName).append(" ").append("rac$result");
                code.append(" = ").append(TransUtils.defaultValue(methodDecl.returnType())).append(";\n");
                if (qcode.contains("rac$result")) {
                    code.append("    final ").append(this.methodDecl.getMethod().owner().getJavaName()).append(" ").append("rac$result$qcode;\n");
                    qcode = qcode.replace("rac$result", "rac$result$qcode");
                } else if (qcode.contains("object$rac")) {
                    code.append("    final ").append(this.methodDecl.getMethod().owner().getJavaName()).append(" ").append("rac$result$qcode;\n");
                    qcode = qcode.replace("object$rac", "rac$result$qcode");
                }
            }
        }
        HashMap preconditions = getPreconditions(visibility);
        if (this.hasPreExpressions || this.hasOldVariables || this.hasOldExpressions) {
            if (this.hasOldVariables) {
                for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext(); ) {
                    List oldVarsDeclList = (List) oldVarsDecl.get(iterator.next());
                    if (oldVarsDeclList != null) {
                        for (Iterator iterator2 = oldVarsDeclList.iterator(); iterator2.hasNext(); ) {
                            String currentOldVarDecl = (String) iterator2.next();
                            code.append("    final ").append(currentOldVarDecl.substring(0, currentOldVarDecl.indexOf('/'))).append(";\n");
                        }
                    }
                }
            }
            if (this.hasPreExpressions) {
                for (Iterator iterator = preExprsDecl.iterator(); iterator.hasNext(); ) {
                    String currentPreExprsDecl = (String) iterator.next();
                    code.append("    boolean ").append(currentPreExprsDecl).append(";\n");
                }
            }
            if (this.hasOldExpressions) {
                for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext(); ) {
                    int index = (int) iterator.next();
                    List oldExprsDeclList = (List) oldExprsDecl.get(index);
                    if (oldExprsDeclList != null) {
                        for (Iterator iterator2 = oldExprsDeclList.iterator(); iterator2.hasNext(); ) {
                            String currentOldExprsDecl = (String) iterator2.next();
                            code.append("    final ").append(currentOldExprsDecl).append("\n");
                        }
                    }
                }
            }
            // saving pre-expressions and precondition related old vars
            boolean canGenerate = false;
            if (this.hasOldVariables) {
                outerLoop:
                for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext(); ) {
                    int index = (int) iterator.next();
                    List oldVarsDeclList = (List) oldVarsDecl.get(index);
                    if (oldVarsDeclList != null) {
                        for (Iterator iterator2 = oldVarsDeclList.iterator(); iterator2
                                .hasNext(); ) {
                            String currentOldVar = (String) iterator2.next();
                            String[] currentOldVarParts = currentOldVar.substring(0, currentOldVar.indexOf('/')).replace(";", "").split(" ");
                            String currentOldVarIdent = currentOldVarParts[1];
                            if (AspectUtil.getInstance().isOldVarReferencedWithinPrecondition(preconditions, currentOldVarIdent)) {
                                canGenerate = true;
                                break outerLoop;
                            }
                            if (AspectUtil.getInstance().isOldVarReferencedWithinPreExpr(preExprs, currentOldVarIdent)) {
                                canGenerate = true;
                                break outerLoop;
                            }
                        }
                    }
                }
            }
            if (this.hasPreExpressions) {
                for (Iterator iterator = preExprs.iterator(); iterator.hasNext(); ) {
                    canGenerate = true;
                    break;
                }
            }

            if (canGenerate) {
                code.append("    try {\n");
                code.append("      // saving pre-expressions and precondition related old vars\n");
                if (this.hasOldVariables) {
                    for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext(); ) {
                        int index = (int) iterator.next();
                        List oldVarsDeclList = (List) oldVarsDecl.get(index);
                        if (oldVarsDeclList != null) {
                            for (Iterator iterator2 = oldVarsDeclList.iterator(); iterator2
                                    .hasNext(); ) {
                                String currentOldVar = (String) iterator2.next();
                                String[] currentOldVarParts = currentOldVar.substring(0, currentOldVar.indexOf('/')).replace(";", "").split(" ");
                                String currentOldVarIdent = currentOldVarParts[1];
                                if (AspectUtil.getInstance().isOldVarReferencedWithinPrecondition(preconditions, currentOldVarIdent)) {
                                    code.append("\t\t").append(AspectUtil.changeThisOrSuperRefToAdviceRef((currentOldVar.substring((currentOldVar.indexOf('/') + 1))), typeDecl)).append(";\n");
                                }
                                if (AspectUtil.getInstance().isOldVarReferencedWithinPreExpr(preExprs, currentOldVarIdent)) {
                                    code.append("\t\t").append(AspectUtil.changeThisOrSuperRefToAdviceRef((currentOldVar.substring((currentOldVar.indexOf('/') + 1))), typeDecl)).append(";\n");
                                }
                            }
                        }
                    }
                }
                if (this.hasPreExpressions) {
                    for (Iterator iterator = preExprs.iterator(); iterator.hasNext(); ) {
                        String currentPreExpr = (String) iterator.next();
                        // adding JML quantifierInnerClasses if any
                        code.append(this.getQuantifierInnerClasses(currentPreExpr));
                        code.append("\t\t").append(currentPreExpr).append("\n");
                    }
                }
                code.append("     } catch (Throwable rac$cause) {\n");
                code.append("          if(rac$cause instanceof JMLAssertionError) {\n");
                code.append("            throw (JMLAssertionError) rac$cause;\n");
                code.append("          }\n");
                code.append("          else {\n");
                code.append("            throw new JMLEvaluationError(\"\" + rac$cause);\n");
                code.append("          }\n");
                code.append("     }");
                code.append("\n");
            }
        }
        // saving old expressions or old variables not mentioned within preconditions
        for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext(); ) {
            int index = (int) iterator.next();
            List oldVarsDeclList = (List) oldVarsDecl.get(index);
            List oldExprsList = (List) oldExprs.get(index);
            boolean canGenerate = false;
            if ((oldVarsDeclList != null)) {
                for (Iterator iterator2 = oldVarsDeclList.iterator(); iterator2
                        .hasNext(); ) {
                    String currentOldVar = (String) iterator2.next();
                    String[] currentOldVarParts = currentOldVar.substring(0, currentOldVar.indexOf('/')).replace(";", "").split(" ");
                    String currentOldVarIdent = currentOldVarParts[1];
                    if (!AspectUtil.getInstance().isOldVarReferencedWithinPrecondition(preconditions, currentOldVarIdent) &&
                            !AspectUtil.getInstance().isOldVarReferencedWithinPreExpr(preExprs, currentOldVarIdent)) {
                        canGenerate = true;
                        break;
                    }
                }
            }
            if ((oldExprsList != null)) {
                for (Iterator iterator2 = oldExprsList.iterator(); iterator2
                        .hasNext(); ) {
                    canGenerate = true;
                    break;
                }
            }
            if (canGenerate) {
                String precondition = (String) preconditions.get(index);
                code.append("    if (").append(precondition).append(") {\n");
                {
                    code.append("        // saving old expressions and old vars related to each spec case\n");
                    if ((oldVarsDeclList != null)) {
                        for (Iterator iterator2 = oldVarsDeclList.iterator(); iterator2
                                .hasNext(); ) {
                            String currentOldVar = (String) iterator2.next();
                            String[] currentOldVarParts = currentOldVar.substring(0, currentOldVar.indexOf('/')).replace(";", "").split(" ");
                            String currentOldVarIdent = currentOldVarParts[1];
                            if (!AspectUtil.getInstance().isOldVarReferencedWithinPrecondition(preconditions, currentOldVarIdent) &&
                                    !AspectUtil.getInstance().isOldVarReferencedWithinPreExpr(preExprs, currentOldVarIdent)) {
                                code.append("        ").append(AspectUtil.changeThisOrSuperRefToAdviceRef((currentOldVar.substring((currentOldVar.indexOf('/') + 1))), typeDecl)).append(";\n");
                            }
                        }
                    }
                    if ((oldExprsList != null)) {
                        for (Iterator iterator2 = oldExprsList.iterator(); iterator2.hasNext(); ) {
                            String currentOldExpr = (String) iterator2.next();
                            code.append("        ").append(AspectUtil.changeThisOrSuperRefToAdviceRef(currentOldExpr, this.typeDecl)).append("\n");
                        }
                    }
                }
                code.append("    } else {\n");
                {
                    if (this.hasOldVariables) {
                        if ((oldVarsDeclList != null)) {
                            for (Iterator iterator2 = oldVarsDeclList.iterator(); iterator2
                                    .hasNext(); ) {
                                String currentOldVar = (String) iterator2.next();
                                String[] currentOldVarParts = currentOldVar.substring(0, currentOldVar.indexOf('/')).replace(";", "").split(" ");
                                String currentOldVarType = currentOldVarParts[0];
                                String currentOldVarIdent = currentOldVarParts[1];
                                if (!AspectUtil.getInstance().isOldVarReferencedWithinPrecondition(preconditions, currentOldVarIdent) &&
                                        !AspectUtil.getInstance().isOldVarReferencedWithinPreExpr(preExprs, currentOldVarIdent)) {
                                    code.append("      ").append(currentOldVarIdent).append(" = ").append(TransUtils.defaultValue(currentOldVarType)).append(";\n");
                                }
                            }
                        }
                    }
                    if (this.hasOldExpressions) {
                        List oldExprsDeclList = (List) oldExprsDecl.get(index);
                        if ((oldExprsList != null)) {
                            for (Iterator iterator2 = oldExprsDeclList.iterator(); iterator2.hasNext(); ) {
                                String currentOldExprsDecl = (String) iterator2.next();
                                String[] currentOldExprsParts = currentOldExprsDecl.replace(";", "").split(" ");
                                String currentOldExprType = currentOldExprsParts[0];
                                String currentOldExprIdent = currentOldExprsParts[1];
                                code.append("      ").append(currentOldExprIdent).append(" = ").append(TransUtils.defaultValue(currentOldExprType)).append(";\n");
                            }
                        }
                    }
                }
                code.append("    }\n");
            }
        }
        code.append("    try {\n");
        {
            if (isMethodCrosscutSpecChecking) {
                code.append("      rac$result = ").append(this.buildCallProceed(parameters, instrumentationType, isMethodCrosscutSpecChecking, isFlexibleXCS)).append(";").append("//executing the method\n");
                if (qcode.contains("rac$result")) {
                    code.append("      rac$result$qcode = rac$result;\n");
                }
            } else if ((!(methodReturnType.equals("void"))) || (methodDecl.isConstructor() && (instrumentationType.equals("callSite") || instrumentationType.equals("clientAwareChecking")))) {
                code.append("      rac$result = ").append(this.buildCallProceed(parameters, instrumentationType, isMethodCrosscutSpecChecking, isFlexibleXCS)).append(";//executing the method\n");
                if (qcode.contains("rac$result")) {
                    code.append("      rac$result$qcode = rac$result;\n");
                }
            } else {
                code.append("      ").append(this.buildCallProceed(parameters, instrumentationType, isMethodCrosscutSpecChecking, isFlexibleXCS)).append(";//executing the method\n");
            }
            code.append(qcode);
            HashMap nPostconditions = getNormalPostconditions(visibility);
            for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext(); ) {
                int index = (int) iterator.next();
                String postcondition = (String) nPostconditions.get(index);
                if (AspectUtil.hasAssertion(postcondition)) {
                    String precondition = (String) preconditions.get(index);
                    if (methodDecl.isConstructor() && (visibility != -1)) {
                        precondition = precondition.replace("object$rac", "rac$result");
                        postcondition = postcondition.replace("object$rac", "rac$result");
                    }
                    code.append("      if (").append(precondition).append(") {\n");
                    code.append("        cute.Cute.Assert(").append(postcondition).append(");\n");
                    code.append("      }\n");
                }
            }
        }
        code.append("    } catch (Throwable rac$e) {\n");
        {
            for (Iterator iterator = xPostCode.iterator(); iterator.hasNext(); ) {
                String signalClause = (String) iterator.next();
                code.append(signalClause);
            }
            code.append("\n");
            code.append(this.xPostRethrowStmt());
        }
        code.append("    }\n");
        if (isMethodCrosscutSpecChecking || !methodReturnType.equals("void")
                || (methodDecl.isConstructor() && (instrumentationType.equals("callSite") || instrumentationType.equals("clientAwareChecking")))) {
            code.append("    return rac$result;\n");
        }
        code.append("  }\n");
        return code;
    }

    private StringBuffer generateNormalAndXPostCheckWithAfterReturningAndAfterThrowingAdvice(
            String nPostPred, List xPostCode, String instrumentationType, long visibility) {
        StringBuffer code = new StringBuffer();
        if (!nPostPred.equals("") && !nPostPred.equals("true")) {
            code = this.generateNormalPostCheckWithAfterReturningAdvice(nPostPred, instrumentationType, visibility);
        }
        this.setJavadocForXPostMethodAdvice();
        code.append(this.generateXPostcheckWithAfterThrowingAdvice(xPostCode, instrumentationType, visibility));
        return code;
    }

    private StringBuffer generateNormalPostCheckWithAfterReturningAdvice(String nPostPred, String instrumentationType, long visibility) {
        boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
        StringBuffer code = this.buildAdviceHeader("NPAssertionMethodWithAfterReturningAdvice", instrumentationType, visibility, isMethodCrosscutSpecChecking);
        code.append("  {\n");
        {
            if (isMethodCrosscutSpecChecking) {
                code.append("    String runtimeObjectOrStaticType = \"\";\n");
                code.append("    String methSig = \"\";\n");
                code.append("    if (thisJoinPoint.getKind().equals(thisJoinPoint.CONSTRUCTOR_CALL)){\n");
                code.append("      runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
                code.append("      methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(runtimeObjectOrStaticType));\n");
                code.append("      methSig = methSig.replace(runtimeObjectOrStaticType, runtimeObjectOrStaticType+\".<init>\");\n");
                code.append("    } else {\n");
                code.append("      if (java.lang.reflect.Modifier.isStatic(thisJoinPoint.getSignature().getModifiers())){\n");
                code.append("        runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
                code.append("      } else if (thisJoinPoint.getThis() != null) {\n");
                code.append("        runtimeObjectOrStaticType = thisJoinPoint.getThis().getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(thisJoinPoint.getThis()));\n");
                code.append("      } else {\n");
                code.append("        runtimeObjectOrStaticType = thisJoinPoint.getTarget().getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(thisJoinPoint.getTarget()));\n");
                code.append("      }\n");
                code.append("      methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(thisJoinPoint.getSignature().getName()));\n");
                code.append("    }\n");
            }
            // adding JML quantifierInnerClasses if any
            code.append(this.getQuantifierInnerClasses(nPostPred));
            HashMap preconditions = getPreconditions(visibility);
            HashMap nPostconditions = getNormalPostconditions(visibility);
            for (Iterator iterator = preconditions.keySet().iterator(); iterator.hasNext(); ) {
                int index = (int) iterator.next();
                String normalPostcondition = (String) nPostconditions.get(index);
                if (AspectUtil.hasAssertion(normalPostcondition)) {
                    String precondition = (String) preconditions.get(index);
                    code.append("     if (").append(precondition).append(") {\n");
                    code.append("       cute.Cute.Assert(").append(normalPostcondition).append(");\n");
                    code.append("     }\n");
                }
            }
        }
        code.append("  }\n");
        return code;
    }

    private StringBuffer generateXPostcheckWithAfterThrowingAdvice(List xPostCode, String instrumentationType, long visibility) {
        boolean isMethodCrosscutSpecChecking = AspectUtil.getInstance().isCrosscutSpecChecking(this.methodDecl);
        StringBuffer code = this.buildAdviceHeader("XPAssertionMethodWithAfterThrowingAdvice", instrumentationType, visibility,
                isMethodCrosscutSpecChecking);
        code.append("  {\n");
        {
            if (isMethodCrosscutSpecChecking) {
                code.append("     String runtimeObjectOrStaticType = \"\";\n");
                code.append("     String methSig = \"\";\n");
                code.append("     if(thisJoinPoint.getKind().equals(thisJoinPoint.CONSTRUCTOR_CALL)){\n");
                code.append("       runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
                code.append("       methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(runtimeObjectOrStaticType));\n");
                code.append("       methSig = methSig.replace(runtimeObjectOrStaticType, runtimeObjectOrStaticType+\".<init>\");\n");
                code.append("     }\n");
                code.append("     else{\n");
                code.append("       if(java.lang.reflect.Modifier.isStatic(thisJoinPoint.getSignature().getModifiers())){\n");
                code.append("          runtimeObjectOrStaticType = thisJoinPoint.getSignature().getDeclaringTypeName();\n");
                code.append("       }\n");
                code.append("       else{\n");
                code.append("          if(thisJoinPoint.getThis() != null){\n");
                code.append("             runtimeObjectOrStaticType = thisJoinPoint.getThis().getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(thisJoinPoint.getThis()));\n");
                code.append("          }\n");
                code.append("          else {\n");
                code.append("             runtimeObjectOrStaticType = thisJoinPoint.getTarget().getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(thisJoinPoint.getTarget()));\n");
                code.append("          }\n");
                code.append("       }\n");
                code.append("         methSig = thisJoinPoint.getSignature().toLongString().substring(thisJoinPoint.getSignature().toLongString().indexOf(thisJoinPoint.getSignature().getName()));\n");
                code.append("    }\n");
            }
            for (Iterator iterator = xPostCode.iterator(); iterator.hasNext(); ) {
                String signalClause = (String) iterator.next();
                code.append(signalClause);
            }
            if (xPostCode.size() > 0) {
                code.append("\n");
            }
            // code responsible to ensure the exception introduction pattern functionality by Laddad --- [[[hemr]]]
            CClassType exceptions[] = this.methodDecl.getExceptions();
            if (exceptions.length > 0) {
                for (int i = 0; i < exceptions.length; i++) {
                    CClassType cType = exceptions[i];
                    // complementing exception signals set --- [[[hemr]]]
                    AspectUtil.getInstance().appendExceptionInSignalsClauseInCompilationUnit(cType);
                }
            }
        }
        code.append("  }\n");
        return code;
    }

    // ----------------------------------------------------------------------
    // DATA MEMBERS
    // ----------------------------------------------------------------------
    /**
     * Return type of the method declaration
     */
    protected CType returnType;
    protected boolean hasPreExpressions;
    protected boolean hasOldVariables;
    protected boolean hasOldExpressions;
}
